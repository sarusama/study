# 1.2 JavaScript实现

```
ECMAScript
DOM Document Object Model
BOM Browser Object Model
```

## ECMAScript 提供核心语言功能

规定了语法，类型，语句，关键字，保留字，操作符，对象

## DOM -- Document Object Model 文档对象模型 提供访问和操作网页内容的方法和接口



## BOM -- Browser Object Model 浏览器对象模型 提供与浏览器交互的方法和接口

弹出新浏览器窗口
移动、缩放和关闭浏览器窗口
浏览器的详细信息：navigator对象
浏览器所加载页面的详细信息：location对象
用户显示器分辨率的详细信息：screen对象
cookie

# 2.1 <script> 标签元素

例子：
```
    <!DOCTYPE html>
    <html>
        <head>
            <title>网页标题</title>
        </head>
        <body>
            <script src = "./example.js" type = "text/javascript"></script>
        </body>
    </html>
```

属性：
```
    async：表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或者等待加载其他脚本。只对外部脚本文件有效。即在script属性中有src。
    charset：表示通过src属性的指定的代码的字符集。由于大多数浏览器会忽略它的值，因此该属性很少有人使用。
    defer：表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。
    src：表示包含要执行代码的外部文件。
    type：表示编写代码使用的脚本语言的内容类型（也被称为MIME类型）。
```

通过<script>元素的src属性还可以包含来自外部域的JavaScript脚本文件。
这一点<script>和<img>元素非常相似，即它的src属性可以是指向当前页面所在所在域之外的某个域的完整链接。
利用这一点就可以在必要时通过不同域来提供JavaScript脚本文件。不过，在访问自己不能控制的服务器上的JavaScript脚本文件时则需要多加小心。如果不幸遇到了怀有恶意的程序员，那他们随时都有可能替换该文件中的代码。
可以利用这一点进行跨域操作。

无论如何包含代码，只要不存在defer和async属性，浏览器都会按照<script>元素在页面中出现的先后顺序对它们依次进行解析。


一般将<script>标签放在页面内容的后面，防止页面先将<script>中的内容下载，解析和执行完成之后再开始渲染页面。

## 延迟脚本

<script defer = "defer" type = "text/javascript" src = "./example.js"></script>

## 异步脚本

<script async type = "text/javascript" src = "./example.js"></script>


# 文档模式

DOCTYPE
<!--  HTML5  -->
<!DOCTYPE html>

## 混杂模式

## 标准模式

# <noscript>标签

当
```
浏览器不支持脚本
浏览器支持脚本，但是脚本被禁用。
```
时，会显示其中的内容。

# 数据类型

简单数据类型:
undefined
null
boolean
string
number
复杂数据类型:
function
object

object为空时，是null。function也是object,Array也是object。
number为空时，是Nan（Not A Number）。

### 字符串加减运算操作原理

两个字符串相加，先创建一个能容纳两个字符串之和的空间，然后再按先后顺序将两个字符串填充进去，最后销毁原来的两个字符串。

### 前置递增和递减 与 后置递增和递减 的区别
```
    var num1 = 2;
    var num2 = 2;
    var num3 = 20;
    var num4 = num1-- + num3;  //22
    var num5 = --num2 + num3;  //21
```
#### 递增递减操作符规则：
```
    var s1 = "2";
    var s2 = "z";
    var b = false;
    var f = 1.1;
    var o = {
        valueOf: function () {
            return -1;
        }
    }

    s1++ //3
    s2++ //Nan
    b++  //1
    f--  //0.10000000000000009
    o--  //-2
```

### 布尔操作符

#### !

```
  !false       //true
  !"blue"      //false
  !0           //true
  !Nan         //true
  !""          //true
  !1234        //false
  !!false      //false
  !!"blue"     //true
  !!0          //false
  !!Nan        //false
  !!""         //false
  !!1234       //true
```

#### &&

逻辑与规则:

```
    如果第一个操作数是对象，则返回第二个操作数；
    如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；
    如果两个操作数都是对象，则返回第二个操作数；
    如果一个操作数为null，则返回null；
    如果一个操作数为undefined， 则返回undefined；
    如果一个操作数为Nan，则返回Nan。
```

注：逻辑与操作属于短路操作。

短路操作：即第一个操作数可以决定结果，那么就不会再对第二个操作数进行求值。

#### ||

逻辑或规则:
```
   如果第一个操作数是对象，则返回第一个操作数；
   如果第一个操作数的求值结果为false，则返回第二个操作数；
   如果两个操作数都是对象，则返回第一个操作数；
   如果两个操作数都是null，则返回null；
   如果两个操作数都是Nan，则返回Nan；
   如果两个操作数都是undefined，则返回undefined。
```

注：逻辑或操作也属于短路操作。

```
   var object1 = object2 || object3;
```
在上述例子中，如果object2不为null,那么将object2赋值给object1.反之，也就是object2为null,那么就将object3赋值给object1.

#### +

加性操作符规则：
```
   其他的就不多赘述了，就记录一些不是正常情况的。
   +0 + +0    // +0
   -0 + -0    // -0
   +0 + -0    // +0
```

#### -

减性操作符规则：
```
   和加性操作符一样，减性操作符也有一些不是正常情况：
   +0 - +0 // +0
   +0 - -0 // -0
   -0 - -0 // +0
```

#### ==, !=

相等操作符和不相等操作符:
```
   如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值--false转换为0，true转换为1;
   如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
   如果一个操作数是对象，另一个操作数不是，则调用对象的valueof()方法，用得到的基本类型值按照前面的规则进行比较；

   null 和 undefined 是相等的;
   要比较相等性之前，不能将null和undefined转换为其他任何值。
   如果有一个操作数是NaN，则相等操作符返回false,而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false,因为按照规则，NaN不等于NaN。
   如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。
```
例子:
```
   null == undefined   // true
   "NaN" == NaN        // false
   5 == NaN            // false
   NaN == NaN          // false
   NaN != NaN          // true
   false == 0          // true
   true == 1           // true
   true == 2           // false
   undefined == 0      // false
   null == 0           // false
   "5" == 5            // true
```

#### ===, !==

全等操作符和不全等操作符：
全等操作符并不会将操作数进行转换，只在两个操作数未经转换就相等的情况下返回true。

由于相等和不相等操作符存在类型转换问题，而为了保持代码中的数据类型的完整性，建议使用全等和不全等操作符。

### 条件操作符

variable = booleanExpression ? trueValue : falseValue;

### 赋值操作符

以下是符合赋值操作符:
```
   +=加赋值
   -=减赋值
   *=乘赋值
   /=除赋值
   %=模赋值|余赋值
   <<=左移赋值
   >>=无符号右移赋值
   >>>=有符号右移赋值
```

### 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作。

```
  var num1 = 1,
      num2 = 2,
      num3 = 3;
```

逗号操作符多用于声明多个变量；逗号操作符还可以用于赋值。
在用于赋值时，逗号操作符总会返回表达式中的最后一项：
```
   var num = ( 0, 1, 2, 3 );
   console.log(num);            // 3
```

## 语句

### if 语句
if语句语法:
```
  if ( condition|条件 ) {
      statement1|语句1
  } else {
      statement2|语句2
  }
```

其中的condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对condition求值的结果为true,则执行statement1（语句1），如果对condition求值的结果为false,则执行statement2（语句2）。

### do-while 语句

do-while语句是一种后测试语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。

```
  do {
      statement|语句
  } while ( expression|表达式 )
```

### while 语句

while语句属于前测试语句,也就是说，在循环体内的代码在被执行之前，就会对出口条件求值。因此循环体内的代码有可能永远不会被执行。
```
  while ( expression|表达式 ) {
      statement|语句
  }
```

### for 语句

for语句属于前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。

```
  for (initialization|初始化; expression|表达式; post-loop-expression|循环后表达式) {
      statement|语句
  }
```

### for-in 语句

for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。

```
   for ( property|属性 in expression|表达式 ) {
       statement|语句
   }
```

### label 语句

label语句可以在代码中添加标签，以便将来使用。
```
    label|标签: statement|语句
```

### break 和 continue 语句

break和continue语句用于在循环中精确的控制代码的执行。
break语句会立即退出循环，强制继续执行循环后面的语句。
continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。

### with 语句

with语句的作用是将代码的作用域设置到一个特定的对象中。

```
  with ( expression|表达式 ) {
      statement|语句
  }
  example:
  source code: {
    let hostname = window.location.hostname;
    let url = window.location.href;
  }
  use "with": {
      with ( window.location ) {
          let hostname = hostname;
          url = href;
      }
  }
```
由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

### switch 语句

switch语句与if语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。
```
    switch ( expression|表达式 ) {
        case value|值:
            statement|语句;
            break;
        default:
            statement|语句:
            break;
    }
```
switch语句中的每一种情形（case）的含义是：如果表达式等于这个值（value），则执行后面的语句（statement）。而break关键字会导致代码执行流跳出switch语句。如果省略break关键字，就会导致执行完当前case后，继续执行下一个case。最后的default关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码。

其将按照代码从上往下的顺序进行执行语句，比如：
```
    switch ( 1 ) {
        case 2: 
            console.log(2);
            break;
        case 0:
            console.log(0);
            break;
        case 1:
            console.log(1);
        default:
            console.log("default");
            break;
    }
    /// 1 "default"

    switch ( 1 ) {
        case 2: 
            console.log(2);
            break;
        case 1:
            console.log(1);
        case 0:
            console.log(0);
            break;
        default:
            console.log("default");
            break;
    }
    // 1 0
```

注：switch语句在比较值时使用的是全等操作符。

```
    switch ( 1 ) {
        case "1":
            console.log("1");
            break;
        default:
            console.log("default");
            break;
    }
    /// "default"
```

## 函数
函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时间调用执行。
ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体。
```
function functionName|函数名 ( argv0|参数0, argv1|参数1,..., argvN|参数N ) {
    statements|语句
}
var functionName|函数名 = function ( argv0|参数0, argv1|参数1,..., argvN|参数N ) {
    statements|语句
}
```

函数名也可以省略，变成匿名函数:
```
function ( argv0|参数0, argv1|参数1,..., argvN|参数N ) {
    statements|语句
};
```

ES6中加入了箭头函数：
箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this, arguments, super, new.target。
箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。
```
//  基础语法
var functionName|函数名 = ( argv0|参数0, argv1|参数1,..., argvN|参数N ) => {
    statements|语句
}
let functionName|函数名 = ( argv0|参数0,argv1|参数1,..., argvN|参数N ) => {
    statements|语句
}
( argv0|参数0, argv1|参数1,..., argvN|参数N ) => {
    statements|语句
}
当函数体为一个表达式时：
( argv0|参数0, argv1|参数1,..., argvN|参数N ) => expression|表达式
( argv0|参数0, argv1|参数1,..., argvN|参数N ) => {
    return expression|表达式
}
当参数数目为一时：
( argv0|参数0 ) => {
    statements|语句
}
argv0|参数0 => {
    statements|语句
}
没参数时，需要加上小括号：
() => {
    statements|语句
}
//  高级语法
todoList: 箭头函数高级语法
//  加括号的函数体返回对象字面表达式
( argv0|参数0 ) => ( { foo: bar } )
//  相当于
( argv0|参数0 ) => {
    return {
        foo: bar
    }
}

//  支持剩余参数和默认参数
( argv0|参数0, argv1|参数1, ...rest|剩下的 ) => {
    statements|语句
}
( argv0|参数0 = default0|默认值0, argv1|参数1 = default1|默认1,..., argvN|参数N = defaultN|默认值N ) => {
    statements|语句
}
//  支持参数结构
let f = ( [a, b] = [1, 2], { x: c } = { x: a + b } ) => a + b + c;
f() //  6
```
箭头函数与普通函数的区别：
* 更简短的函数并且不绑定this
* 在箭头函数出现之前，每个新定义的函数都有它自己的this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为undefined，如果该函数被作为“对象方法”调用则为基础对象等）。
```
与严格模式的关系：
鉴于this是词法层次上的，严格模式中与this相关的规则都会被忽略。
通过call和apply调用:
由于箭头函数没有自己的this指针，通过call()和apply()方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。
例：
`
var adder = {
    base : 1,
    add : function(a) {
        var f = v => v + this.base;
        return f(a);
    },
    addThruCall: function(a) {
        var f = v => v + this.base;
        var b = {
            base : 2
        };   
        return f.call(b, a);
    }
};
console.log(adder.add(1));         // 输出 2
console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3）
`
```
* 不绑定arguments
```
箭头函数不绑定Arguments对象。因此，在本示例中，arguments只是引用了封闭作用域内的arguments:
`
var arguments = [1, 2, 3];
var arr = () => arguments[0];

arr(); // 1

function foo(n) {
    var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n
    return f();
}

foo(1); // 2
`
在大多数情况下，使用剩余参数是相较使用arguments对象的更好选择。
`
function foo(arg) { 
    var f = (...args) => args[0]; 
    return f(arg); 
}
foo(1); // 1

function foo(arg1, arg2) { 
    var f = (...args) => args[1]; 
    return f(arg1,arg2); 
} 
foo(1,2);  //2
`
```
* 箭头函数表达式对非方法函数是最合适的。
* 箭头函数不能用作构造器，和new一起使用会抛出错误。
* 箭头函数没有proptype属性。
* yield关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。
* 箭头函数在参数和箭头之间不能换行。
* 箭头函数解析顺序
```
let callback = undefined;
callback = callback || function () {};
// no Error
callback = callback || () => {};
// error
callback = callback || (() => {});
// no Error
```

箭头函数体：
```
let functionName = ( argv ) => argv + argv;
let functionName = ( argv ) => {
    return argv + argv;
}
```
返回对象字面量：
```
记住用params => { object: literal } 这种简单的语法返回对象字面量是行不通的。
如需返回对象字面量，需要将式子改为
params => ({ object: literal })
```

箭头函数例子：
```
// 空的箭头函数返回 undefined
let empty = () => {};

(() => 'foobar')(); 
// Returns "foobar"
// (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) 

// 三元运算符
var simple = a => a > 15 ? 15 : a; 
simple(16); // 15
simple(10); // 10

let max = (a, b) => a > b ? a : b;

// Easy array filtering, mapping, ...
var arr = [5, 6, 13, 0, 1, 18, 23];

var sum = arr.reduce((a, b) => a + b);  
// 66

var even = arr.filter(v => v % 2 == 0); 
// [6, 0, 18]

var double = arr.map(v => v * 2);       
// [10, 12, 26, 0, 2, 36, 46]

// 更简明的promise链
promise.then(a => {
  // ...
}).then(b => {
  // ...
});

// 无参数箭头函数在视觉上容易分析
setTimeout( () => {
  console.log('I happen sooner');
  setTimeout( () => {
    // deeper code
    console.log('I happen later');
  }, 1000);
}, 1000);
```

箭头函数内定义的变量及其作用域
```
// 常规写法
var greeting = () => {
    let now = new Date(); 
    return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));
}
greeting();          //"Good day."
console.log(now);    // ReferenceError: now is not defined 标准的let作用域

// 参数括号内定义的变量是局部变量（默认参数）
var greeting = ( now = new Date() ) => "Good" + (now.getHours() > 17 ? " evening." : " day.");
greeting();          //"Good day."
console.log(now);    // ReferenceError: now is not defined

// 对比：函数体内{}不使用var定义的变量是全局变量
var greeting = () => {
    now = new Date(); 
    return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));
}
greeting();           //"Good day."
console.log(now);     // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)

// 对比：函数体内{} 用var定义的变量是局部变量
var greeting = () => {
    var now = new Date(); 
    return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));
}
greeting(); //"Good day."
console.log(now);    // ReferenceError: now is not defined
```

箭头函数也可以使用闭包：
```
// 标准的闭包函数
function A () {
    var i = 0;
    return function b () {
        return ( ++i );
    };
};

var v = A();
v();    //1
v();    //2


//箭头函数体的闭包（ i=0 是默认参数）
var Add = ( i = 0 ) => {
    return ( () => ( ++i ) );
};
var v = Add();
v();           //1
v();           //2

//因为仅有一个返回，return 及括号（）也可以省略
var Add = ( i = 0 ) => () => ( ++i );
```

箭头函数递归:
```
var fact = (x) => ( x == 0 ?  1 : x * fact( --x ) );
fact(5);       // 120
```

** 推荐的做法是要么让函数始终都返回值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候不返回值，会给调试代码带来不便 **

无须指定函数的返回值，但实际上，未指定返回值的函数返回的是一个特殊的undefined值。

严格模式下对函数有一些限制：
- 不能将函数命名为eval或arguments;
- 不能将参数命名为eval或arguments;
- 不能出现两个命名参数同名的情况。

### 理解参数

ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有怨言。<b>之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。</b>函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。
其实，agruments对象只是与数组类似（它并不是Array的实例，它只有length，没有pop，push等方法），因为可以使用方括号语法访问他的每一个元素（即第一个元素为arguments[0]，第二个元素为arguments[1]，以此类推），使用length属性来确定传递进来多少个参数。因此函数也可以这么写：
```
let functionName = function () {
    arguments[0]作为第一个参数
    以此类推
}
```
这说明了ECMAScript函数的一个重点特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要实现创建一个函数签名，而将来的调用必须与该签名一致。但是在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。arguments的长度不是由定义函数时的命名参数的个数决定的，是由传入的参数个数决定的。关于参数还要记住最后一点：没有传递值的命名参数将自动赋予undefined值。
严格模式对如何使用arguments对象做出了一些限制。首先，像在函数内改变参数对应的arguments值会变无效；其次，重写arguments的值会导致语法错误（代码将不会运行）。

ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

### 没有重载

ECMAScript函数不能像传统意义上那样实现重载。在其他语言（如Java，C++）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可。如上所述，ECMAScript函数没有签名，因为其函数的参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。
如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。根据检查传入函数中参数的类型和数量并作出不同的反应， 可以模仿方法的重载。


# 基本类型和引用类型的值
按照ECMA-262的定义，Javascript的变量和其他语言的变量有着很大的区别。Javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某个角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但Javascript变量实际的复杂程度还远不止如此。

ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。
在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
5种基本数据类型：
```
Boolean,Undefined,Null,Number,String
```
上述5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。
引用类型的值时保存在内存中的对象。与其他语言不同，Javascript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。但是这并不严谨，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。

## 动态的属性
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。如果我们为引用类型值添加了一个属性，如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。
但我们并不能给基本类型的值添加属性，尽管这样做不会导致任何错误，但是并不能访问到该属性。这说明只能给引用类型值动态的添加属性，以便将来使用。

## 复制变量值

除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

## 传递参数

ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量按值和按引用两种方式，而参数只能按值传递。
在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

## 检测类型

typeof操作符只能确定一个变量是字符串、数值、布尔值和undefined。
instanceof操作符可以判断变量是什么类型的对象。
基本语法：
```
   result|结果 = variable|变量 instanceof constructor|对象类型
```

# 执行环境及作用域

执行环境（后文都简称为环境）是Javascript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境对象被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出--例如关闭网页或浏览器--时才会被销毁）。
每3个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，ECMAScript程序中的执行流正是由这个方便的机制控制者。
当代码在一个执行环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以想上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。

## 延长作用域链

虽然执行环境的类型总共只有两种--全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：
- try...catch语句的catch块:
- with语句
这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
```
在IE8及之前版本的Javascript实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。
```
## 没有块级作用域

Javascript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码块都有自己的作用域（如果用EMCMAScript的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量。

### 声明变量

使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的函数就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。
```
在编写Javascript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。
```

### 查询标识符

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程立即停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。
```
变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。Javascript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。
```

## 垃圾收集

Javascript具有自动垃圾收集机制，也就是说。执行环境会负责管理代码执行过程中使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写Javascript程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的远原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。
局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有的情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

### 标记清除

Javascript中最常用的垃圾收集方式是标记清除。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境”变量列表及一个“离开环境”的变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不需要，关键在于采取什么策略。
垃圾收集器在运行时会给存储在内存中的所有变量都打上标记（当然，可以使用任何标记方式）。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

另一种不太常见的垃圾收集策略叫做引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用计数加1。相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。
此垃圾收集策略有个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。
例子：
```
function recycle() {
    var objectA = new Object();
    var objectB = new Object();

    objectA.someObject = objectB;
    objectB.anotherObject = objectA;
}
在这个例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。
```
IE中有一部分对象并不是原生Javascript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Components Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的Javascript引擎是使用标记清除策略来实现的，但Javascript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。
为了避免类似这样的循环引用问题，最好是在不使用它们的时候手动断开它们的相互引用。
```
objectA.someObject = null;
objectB.anotherObject = null;
```
将变量设置为null意味着切断变量与它此前引用的值之间的联系。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

## 性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多久运行一次，不禁让人联想到IE因此声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。
随着IE7的发布，其Javascript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量，字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了IE在运行包含大量Javascript的页面时的性能。
```
事实上，在有的浏览器中可以触发垃圾收集过程，但不建议这么做。
```

## 管理内存

使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，Javascript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行Javascript的网页耗尽全部系统内存而导致面临系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用--这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动地解除引用。不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
- 函数的局部执行环境不仅有权访问函数作用域内的变量，而且有权访问其包含（父）环境，乃至全局环境；
- 全局执行环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部执行环境中的任何数据；
- 变量的执行环境有助于确定应该何时释放内存。
- 离开作用域的值将被自动标记为可回收，因此将在垃圾收集期间被删除；
- “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存；
- 另一种垃圾收算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。Javascript引擎目前都不再使用这种算法；但在IE中访问非原生Javascript对象（如COM对象）时，这种算法仍然可能会导致问题；
- 当代码中存在循环引用现象时，“引用计数”算法就会导致问题；
- 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

# 引用类型值

引用类型值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它并不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
```
虽然引用类型和类看起来相似，但它们并不是相同的概念。
类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。
类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为准则，而这些对象就被称为该类的实例。类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分多个属性。类与某个层的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。
类的出现，为面向对象编程的三个最重要的特性（封装性、继承性、多态性），提供了实现的手段。
```
如上所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身是一个函数，只不过该函数是出于创建新对象的目的而定义的。ECMAScript提供了

## Object类型

到目前为止，我们看到的大多数引用类型值都是object类型的实例；而且，object也是ECMAScript中使用最多的一个类型。虽然object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。
创建object实例的方式有两种。第一种是使用new操作符后跟object构造函数。另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。
虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数函数传递大量可传递参数的首选方式。
```
这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来说，命名参数虽然容易处理，但在有多个可选参数的情况下就会显得不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。
```







