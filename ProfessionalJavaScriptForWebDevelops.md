# 1.2 JavaScript实现

```
ECMAScript
DOM Document Object Model
BOM Browser Object Model
```

## ECMAScript 提供核心语言功能

规定了语法，类型，语句，关键字，保留字，操作符，对象

## DOM -- Document Object Model 文档对象模型 提供访问和操作网页内容的方法和接口



## BOM -- Browser Object Model 浏览器对象模型 提供与浏览器交互的方法和接口

弹出新浏览器窗口
移动、缩放和关闭浏览器窗口
浏览器的详细信息：navigator对象
浏览器所加载页面的详细信息：location对象
用户显示器分辨率的详细信息：screen对象
cookie

# 2.1 <script> 标签元素

例子：
```
    <!DOCTYPE html>
    <html>
        <head>
            <title>网页标题</title>
        </head>
        <body>
            <script src = "./example.js" type = "text/javascript"></script>
        </body>
    </html>
```

属性：
```
    async：表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或者等待加载其他脚本。只对外部脚本文件有效。即在script属性中有src。
    charset：表示通过src属性的指定的代码的字符集。由于大多数浏览器会忽略它的值，因此该属性很少有人使用。
    defer：表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。
    src：表示包含要执行代码的外部文件。
    type：表示编写代码使用的脚本语言的内容类型（也被称为MIME类型）。
```

通过<script>元素的src属性还可以包含来自外部域的JavaScript脚本文件。
这一点<script>和<img>元素非常相似，即它的src属性可以是指向当前页面所在所在域之外的某个域的完整链接。
利用这一点就可以在必要时通过不同域来提供JavaScript脚本文件。不过，在访问自己不能控制的服务器上的JavaScript脚本文件时则需要多加小心。如果不幸遇到了怀有恶意的程序员，那他们随时都有可能替换该文件中的代码。
可以利用这一点进行跨域操作。

无论如何包含代码，只要不存在defer和async属性，浏览器都会按照<script>元素在页面中出现的先后顺序对它们依次进行解析。


一般将<script>标签放在页面内容的后面，防止页面先将<script>中的内容下载，解析和执行完成之后再开始渲染页面。

## 延迟脚本

<script defer = "defer" type = "text/javascript" src = "./example.js"></script>

## 异步脚本

<script async type = "text/javascript" src = "./example.js"></script>


# 文档模式

DOCTYPE
<!--  HTML5  -->
<!DOCTYPE html>

## 混杂模式

## 标准模式

# <noscript>标签

当
```
浏览器不支持脚本
浏览器支持脚本，但是脚本被禁用。
```
时，会显示其中的内容。

# 数据类型

简单数据类型:
undefined
null
boolean
string
number
复杂数据类型:
function
object

object为空时，是null。function也是object,Array也是object。
number为空时，是Nan（Not A Number）。

### 字符串加减运算操作原理

两个字符串相加，先创建一个能容纳两个字符串之和的空间，然后再按先后顺序将两个字符串填充进去，最后销毁原来的两个字符串。

### 前置递增和递减 与 后置递增和递减 的区别
```
    var num1 = 2;
    var num2 = 2;
    var num3 = 20;
    var num4 = num1-- + num3;  //22
    var num5 = --num2 + num3;  //21
```
#### 递增递减操作符规则：
```
    var s1 = "2";
    var s2 = "z";
    var b = false;
    var f = 1.1;
    var o = {
        valueOf: function () {
            return -1;
        }
    }

    s1++ //3
    s2++ //Nan
    b++  //1
    f--  //0.10000000000000009
    o--  //-2
```

### 布尔操作符

#### !

```
  !false       //true
  !"blue"      //false
  !0           //true
  !Nan         //true
  !""          //true
  !1234        //false
  !!false      //false
  !!"blue"     //true
  !!0          //false
  !!Nan        //false
  !!""         //false
  !!1234       //true
```

#### &&

逻辑与规则:

```
    如果第一个操作数是对象，则返回第二个操作数；
    如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象；
    如果两个操作数都是对象，则返回第二个操作数；
    如果一个操作数为null，则返回null；
    如果一个操作数为undefined， 则返回undefined；
    如果一个操作数为Nan，则返回Nan。
```

注：逻辑与操作属于短路操作。

短路操作：即第一个操作数可以决定结果，那么就不会再对第二个操作数进行求值。

#### ||

逻辑或规则:
```
   如果第一个操作数是对象，则返回第一个操作数；
   如果第一个操作数的求值结果为false，则返回第二个操作数；
   如果两个操作数都是对象，则返回第一个操作数；
   如果两个操作数都是null，则返回null；
   如果两个操作数都是Nan，则返回Nan；
   如果两个操作数都是undefined，则返回undefined。
```

注：逻辑或操作也属于短路操作。

```
   var object1 = object2 || object3;
```
在上述例子中，如果object2不为null,那么将object2赋值给object1.反之，也就是object2为null,那么就将object3赋值给object1.

#### +

加性操作符规则：
```
   其他的就不多赘述了，就记录一些不是正常情况的。
   +0 + +0    // +0
   -0 + -0    // -0
   +0 + -0    // +0
```

#### -

减性操作符规则：
```
   和加性操作符一样，减性操作符也有一些不是正常情况：
   +0 - +0 // +0
   +0 - -0 // -0
   -0 - -0 // +0
```

#### ==, !=

相等操作符和不相等操作符:
```
   如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值--false转换为0，true转换为1;
   如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
   如果一个操作数是对象，另一个操作数不是，则调用对象的valueof()方法，用得到的基本类型值按照前面的规则进行比较；

   null 和 undefined 是相等的;
   要比较相等性之前，不能将null和undefined转换为其他任何值。
   如果有一个操作数是NaN，则相等操作符返回false,而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false,因为按照规则，NaN不等于NaN。
   如果两个操作数都是对象，则比较他们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。
```
例子:
```
   null == undefined   // true
   "NaN" == NaN        // false
   5 == NaN            // false
   NaN == NaN          // false
   NaN != NaN          // true
   false == 0          // true
   true == 1           // true
   true == 2           // false
   undefined == 0      // false
   null == 0           // false
   "5" == 5            // true
```

#### ===, !==

全等操作符和不全等操作符：
全等操作符并不会将操作数进行转换，只在两个操作数未经转换就相等的情况下返回true。

由于相等和不相等操作符存在类型转换问题，而为了保持代码中的数据类型的完整性，建议使用全等和不全等操作符。

### 条件操作符

variable = booleanExpression ? trueValue : falseValue;

### 赋值操作符

以下是符合赋值操作符:
```
   +=加赋值
   -=减赋值
   *=乘赋值
   /=除赋值
   %=模赋值|余赋值
   <<=左移赋值
   >>=无符号右移赋值
   >>>=有符号右移赋值
```

### 逗号操作符

使用逗号操作符可以在一条语句中执行多个操作。

```
  var num1 = 1,
      num2 = 2,
      num3 = 3;
```

逗号操作符多用于声明多个变量；逗号操作符还可以用于赋值。
在用于赋值时，逗号操作符总会返回表达式中的最后一项：
```
   var num = ( 0, 1, 2, 3 );
   console.log(num);            // 3
```

## 语句

### if 语句
if语句语法:
```
  if ( condition|条件 ) {
      statement1|语句1
  } else {
      statement2|语句2
  }
```

其中的condition（条件）可以是任意表达式；而且对这个表达式求值的结果不一定是布尔值。ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值。如果对condition求值的结果为true,则执行statement1（语句1），如果对condition求值的结果为false,则执行statement2（语句2）。

### do-while 语句

do-while语句是一种后测试语句，即只有在循环体中的代码执行之后，才会测试出口条件。换句话说，在对条件表达式求值之前，循环体内的代码至少会被执行一次。

```
  do {
      statement|语句
  } while ( expression|表达式 )
```

### while 语句

while语句属于前测试语句,也就是说，在循环体内的代码在被执行之前，就会对出口条件求值。因此循环体内的代码有可能永远不会被执行。
```
  while ( expression|表达式 ) {
      statement|语句
  }
```

### for 语句

for语句属于前测试循环语句，但它具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。

```
  for (initialization|初始化; expression|表达式; post-loop-expression|循环后表达式) {
      statement|语句
  }
```

### for-in 语句

for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。

```
   for ( property|属性 in expression|表达式 ) {
       statement|语句
   }
```

### label 语句

label语句可以在代码中添加标签，以便将来使用。
```
    label|标签: statement|语句
```

### break 和 continue 语句

break和continue语句用于在循环中精确的控制代码的执行。
break语句会立即退出循环，强制继续执行循环后面的语句。
continue语句虽然也是立即退出循环，但退出循环后会从循环的顶部继续执行。

### with 语句

with语句的作用是将代码的作用域设置到一个特定的对象中。

```
  with ( expression|表达式 ) {
      statement|语句
  }
  example:
  source code: {
    let hostname = window.location.hostname;
    let url = window.location.href;
  }
  use "with": {
      with ( window.location ) {
          let hostname = hostname;
          url = href;
      }
  }
```
由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。

### switch 语句

switch语句与if语句的关系最为密切，而且也是在其他语言中普遍使用的一种流控制语句。
```
    switch ( expression|表达式 ) {
        case value|值:
            statement|语句;
            break;
        default:
            statement|语句:
            break;
    }
```
switch语句中的每一种情形（case）的含义是：如果表达式等于这个值（value），则执行后面的语句（statement）。而break关键字会导致代码执行流跳出switch语句。如果省略break关键字，就会导致执行完当前case后，继续执行下一个case。最后的default关键字则用于在表达式不匹配前面任何一种情形的时候，执行机动代码。

其将按照代码从上往下的顺序进行执行语句，比如：
```
    switch ( 1 ) {
        case 2: 
            console.log(2);
            break;
        case 0:
            console.log(0);
            break;
        case 1:
            console.log(1);
        default:
            console.log("default");
            break;
    }
    /// 1 "default"

    switch ( 1 ) {
        case 2: 
            console.log(2);
            break;
        case 1:
            console.log(1);
        case 0:
            console.log(0);
            break;
        default:
            console.log("default");
            break;
    }
    // 1 0
```

注：switch语句在比较值时使用的是全等操作符。

```
    switch ( 1 ) {
        case "1":
            console.log("1");
            break;
        default:
            console.log("default");
            break;
    }
    /// "default"
```

## 函数
函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语句，而且可以在任何地方、任何时间调用执行。
ECMAScript中的函数使用function关键字来声明，后跟一组参数以及函数体。
```
function functionName|函数名 ( argv0|参数0, argv1|参数1,..., argvN|参数N ) {
    statements|语句
}
var functionName|函数名 = function ( argv0|参数0, argv1|参数1,..., argvN|参数N ) {
    statements|语句
}
```

函数名也可以省略，变成匿名函数:
```
function ( argv0|参数0, argv1|参数1,..., argvN|参数N ) {
    statements|语句
};
```

ES6中加入了箭头函数：
箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this, arguments, super, new.target。
箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。
```
//  基础语法
var functionName|函数名 = ( argv0|参数0, argv1|参数1,..., argvN|参数N ) => {
    statements|语句
}
let functionName|函数名 = ( argv0|参数0,argv1|参数1,..., argvN|参数N ) => {
    statements|语句
}
( argv0|参数0, argv1|参数1,..., argvN|参数N ) => {
    statements|语句
}
当函数体为一个表达式时：
( argv0|参数0, argv1|参数1,..., argvN|参数N ) => expression|表达式
( argv0|参数0, argv1|参数1,..., argvN|参数N ) => {
    return expression|表达式
}
当参数数目为一时：
( argv0|参数0 ) => {
    statements|语句
}
argv0|参数0 => {
    statements|语句
}
没参数时，需要加上小括号：
() => {
    statements|语句
}
//  高级语法
todoList: 箭头函数高级语法
//  加括号的函数体返回对象字面表达式
( argv0|参数0 ) => ( { foo: bar } )
//  相当于
( argv0|参数0 ) => {
    return {
        foo: bar
    }
}

//  支持剩余参数和默认参数
( argv0|参数0, argv1|参数1, ...rest|剩下的 ) => {
    statements|语句
}
( argv0|参数0 = default0|默认值0, argv1|参数1 = default1|默认1,..., argvN|参数N = defaultN|默认值N ) => {
    statements|语句
}
//  支持参数结构
let f = ( [a, b] = [1, 2], { x: c } = { x: a + b } ) => a + b + c;
f() //  6
```
箭头函数与普通函数的区别：
* 更简短的函数并且不绑定this
* 在箭头函数出现之前，每个新定义的函数都有它自己的this值（在构造函数的情况下是一个新对象，在严格模式的函数调用中为undefined，如果该函数被作为“对象方法”调用则为基础对象等）。
```
与严格模式的关系：
鉴于this是词法层次上的，严格模式中与this相关的规则都会被忽略。
通过call和apply调用:
由于箭头函数没有自己的this指针，通过call()和apply()方法调用一个函数时，只能传递参数，他们的第一个参数会被忽略。
例：
`
var adder = {
    base : 1,
    add : function(a) {
        var f = v => v + this.base;
        return f(a);
    },
    addThruCall: function(a) {
        var f = v => v + this.base;
        var b = {
            base : 2
        };   
        return f.call(b, a);
    }
};
console.log(adder.add(1));         // 输出 2
console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3）
`
```
* 不绑定arguments
```
箭头函数不绑定Arguments对象。因此，在本示例中，arguments只是引用了封闭作用域内的arguments:
`
var arguments = [1, 2, 3];
var arr = () => arguments[0];

arr(); // 1

function foo(n) {
    var f = () => arguments[0] + n; // 隐式绑定 foo 函数的 arguments 对象. arguments[0] 是 n
    return f();
}

foo(1); // 2
`
在大多数情况下，使用剩余参数是相较使用arguments对象的更好选择。
`
function foo(arg) { 
    var f = (...args) => args[0]; 
    return f(arg); 
}
foo(1); // 1

function foo(arg1, arg2) { 
    var f = (...args) => args[1]; 
    return f(arg1,arg2); 
} 
foo(1,2);  //2
`
```
* 箭头函数表达式对非方法函数是最合适的。
* 箭头函数不能用作构造器，和new一起使用会抛出错误。
* 箭头函数没有proptype属性。
* yield关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。
* 箭头函数在参数和箭头之间不能换行。
* 箭头函数解析顺序
```
let callback = undefined;
callback = callback || function () {};
// no Error
callback = callback || () => {};
// error
callback = callback || (() => {});
// no Error
```

箭头函数体：
```
let functionName = ( argv ) => argv + argv;
let functionName = ( argv ) => {
    return argv + argv;
}
```
返回对象字面量：
```
记住用params => { object: literal } 这种简单的语法返回对象字面量是行不通的。
如需返回对象字面量，需要将式子改为
params => ({ object: literal })
```

箭头函数例子：
```
// 空的箭头函数返回 undefined
let empty = () => {};

(() => 'foobar')(); 
// Returns "foobar"
// (这是一个立即执行函数表达式,可参阅 'IIFE'术语表) 

// 三元运算符
var simple = a => a > 15 ? 15 : a; 
simple(16); // 15
simple(10); // 10

let max = (a, b) => a > b ? a : b;

// Easy array filtering, mapping, ...
var arr = [5, 6, 13, 0, 1, 18, 23];

var sum = arr.reduce((a, b) => a + b);  
// 66

var even = arr.filter(v => v % 2 == 0); 
// [6, 0, 18]

var double = arr.map(v => v * 2);       
// [10, 12, 26, 0, 2, 36, 46]

// 更简明的promise链
promise.then(a => {
  // ...
}).then(b => {
  // ...
});

// 无参数箭头函数在视觉上容易分析
setTimeout( () => {
  console.log('I happen sooner');
  setTimeout( () => {
    // deeper code
    console.log('I happen later');
  }, 1000);
}, 1000);
```

箭头函数内定义的变量及其作用域
```
// 常规写法
var greeting = () => {
    let now = new Date(); 
    return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));
}
greeting();          //"Good day."
console.log(now);    // ReferenceError: now is not defined 标准的let作用域

// 参数括号内定义的变量是局部变量（默认参数）
var greeting = ( now = new Date() ) => "Good" + (now.getHours() > 17 ? " evening." : " day.");
greeting();          //"Good day."
console.log(now);    // ReferenceError: now is not defined

// 对比：函数体内{}不使用var定义的变量是全局变量
var greeting = () => {
    now = new Date(); 
    return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));
}
greeting();           //"Good day."
console.log(now);     // Fri Dec 22 2017 10:01:00 GMT+0800 (中国标准时间)

// 对比：函数体内{} 用var定义的变量是局部变量
var greeting = () => {
    var now = new Date(); 
    return ("Good" + ((now.getHours() > 17) ? " evening." : " day."));
}
greeting(); //"Good day."
console.log(now);    // ReferenceError: now is not defined
```

箭头函数也可以使用闭包：
```
// 标准的闭包函数
function A () {
    var i = 0;
    return function b () {
        return ( ++i );
    };
};

var v = A();
v();    //1
v();    //2


//箭头函数体的闭包（ i=0 是默认参数）
var Add = ( i = 0 ) => {
    return ( () => ( ++i ) );
};
var v = Add();
v();           //1
v();           //2

//因为仅有一个返回，return 及括号（）也可以省略
var Add = ( i = 0 ) => () => ( ++i );
```

箭头函数递归:
```
var fact = (x) => ( x == 0 ?  1 : x * fact( --x ) );
fact(5);       // 120
```

** 推荐的做法是要么让函数始终都返回值，要么永远都不要返回值。否则，如果函数有时候返回值，有时候不返回值，会给调试代码带来不便 **

无须指定函数的返回值，但实际上，未指定返回值的函数返回的是一个特殊的undefined值。

严格模式下对函数有一些限制：
- 不能将函数命名为eval或arguments;
- 不能将参数命名为eval或arguments;
- 不能出现两个命名参数同名的情况。

### 理解参数

ECMAScript函数的参数与大多数其他语言中函数的参数有所不同。ECMAScript函数不介意传递进来多少个参数，也不在乎传进来参数是什么数据类型。也就是说，即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有怨言。<b>之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。</b>函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。
其实，agruments对象只是与数组类似（它并不是Array的实例，它只有length，没有pop，push等方法），因为可以使用方括号语法访问他的每一个元素（即第一个元素为arguments[0]，第二个元素为arguments[1]，以此类推），使用length属性来确定传递进来多少个参数。因此函数也可以这么写：
```
let functionName = function () {
    arguments[0]作为第一个参数
    以此类推
}
```
这说明了ECMAScript函数的一个重点特点：命名的参数只提供便利，但不是必需的。另外，在命名参数方面，其他语言可能需要实现创建一个函数签名，而将来的调用必须与该签名一致。但是在ECMAScript中，没有这些条条框框，解析器不会验证命名参数。arguments的长度不是由定义函数时的命名参数的个数决定的，是由传入的参数个数决定的。关于参数还要记住最后一点：没有传递值的命名参数将自动赋予undefined值。
严格模式对如何使用arguments对象做出了一些限制。首先，像在函数内改变参数对应的arguments值会变无效；其次，重写arguments的值会导致语法错误（代码将不会运行）。

ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。

### 没有重载

ECMAScript函数不能像传统意义上那样实现重载。在其他语言（如Java，C++）中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数类型和数量）不同即可。如上所述，ECMAScript函数没有签名，因为其函数的参数是由包含零或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。
如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。根据检查传入函数中参数的类型和数量并作出不同的反应， 可以模仿方法的重载。


# 基本类型和引用类型的值
按照ECMA-262的定义，Javascript的变量和其他语言的变量有着很大的区别。Javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。尽管从某个角度看，这可能是一个既有趣又强大，同时又容易出问题的特性，但Javascript变量实际的复杂程度还远不止如此。

ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。
在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。
5种基本数据类型：
```
Boolean,Undefined,Null,Number,String
```
上述5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。
引用类型的值时保存在内存中的对象。与其他语言不同，Javascript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型的值是按引用访问的。但是这并不严谨，当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。

## 动态的属性
定义基本类型值和引用类型值的方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。如果我们为引用类型值添加了一个属性，如果对象不被销毁或者这个属性不被删除，则这个属性将一直存在。
但我们并不能给基本类型的值添加属性，尽管这样做不会导致任何错误，但是并不能访问到该属性。这说明只能给引用类型值动态的添加属性，以便将来使用。

## 复制变量值

除了保存的方式不同之外，在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，就会影响另一个变量。

## 传递参数

ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。有不少开发人员在这一点上可能会感到困惑，因为访问变量按值和按引用两种方式，而参数只能按值传递。
在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。

## 检测类型

typeof操作符只能确定一个变量是字符串、数值、布尔值和undefined。
instanceof操作符可以判断变量是什么类型的对象。
基本语法：
```
   result|结果 = variable|变量 instanceof constructor|对象类型
```

# 执行环境及作用域

执行环境（后文都简称为环境）是Javascript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它。
全局执行环境是最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境对象被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出--例如关闭网页或浏览器--时才会被销毁）。
每3个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，ECMAScript程序中的执行流正是由这个方便的机制控制者。
当代码在一个执行环境中执行时，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象(这个对象在全局环境中是不存在的)。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以想上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。

## 延长作用域链

虽然执行环境的类型总共只有两种--全局和局部（函数），但还是有其他办法来延长作用域链。这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：
- try...catch语句的catch块:
- with语句
这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。
```
在IE8及之前版本的Javascript实现中，存在一个与标准不一致的地方，即在catch语句中捕获的错误对象会被添加到执行环境的变量对象，而不是catch语句的变量对象中。换句话说，即使是在catch块的外部也可以访问到错误对象。IE9修复了这个问题。
```
## 没有块级作用域

Javascript没有块级作用域经常会导致理解上的困惑。在其他类C的语言中，由花括号封闭的代码块都有自己的作用域（如果用EMCMAScript的话来讲，就是它们自己的执行环境），因而支持根据条件来定义变量。

### 声明变量

使用var声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的函数就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。
```
在编写Javascript代码的过程中，不声明而直接初始化变量是一个常见的错误做法，因为这样可能会导致意外。我们建议在初始化变量之前，一定要先声明，这样就可以避免类似问题。在严格模式下，初始化未经声明的变量会导致错误。
```

### 查询标识符

当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程立即停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域向上搜索。搜索过程将一直追溯到全局环境的变量对象。如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。
```
变量查询也不是没有代价的。很明显，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链。Javascript引擎在优化标识符查询方面做得不错，因此这个差别在将来恐怕就可以忽略不计了。
```

## 垃圾收集

Javascript具有自动垃圾收集机制，也就是说。执行环境会负责管理代码执行过程中使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况，这是造成许多问题的一个根源。在编写Javascript程序时，开发人员不用再关心内存使用问题，所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾收集机制的远原理其实很简单：找到那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。
局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要；但并非所有的情况下都这么容易就能得出结论。垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略。

### 标记清除

Javascript中最常用的垃圾收集方式是标记清除。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者使用一个“进入环境”变量列表及一个“离开环境”的变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不需要，关键在于采取什么策略。
垃圾收集器在运行时会给存储在内存中的所有变量都打上标记（当然，可以使用任何标记方式）。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

另一种不太常见的垃圾收集策略叫做引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用计数加1。相反，如果包含对这个值引用的变量又取得了另一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。
此垃圾收集策略有个严重的问题：循环引用。循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。
例子：
```
function recycle() {
    var objectA = new Object();
    var objectB = new Object();

    objectA.someObject = objectB;
    objectB.anotherObject = objectA;
}
在这个例子中，objectA和objectB通过各自的属性相互引用；也就是说，这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是问题。但在采用引用计数策略的实现中，当函数执行完毕后，objectA和objectB还将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。
```
IE中有一部分对象并不是原生Javascript对象。例如，其BOM和DOM中的对象就是使用C++以COM（Components Object Model，组件对象模型）对象的形式实现的，而COM对象的垃圾收集机制采用的就是引用计数策略。因此，即使IE的Javascript引擎是使用标记清除策略来实现的，但Javascript访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。
为了避免类似这样的循环引用问题，最好是在不使用它们的时候手动断开它们的相互引用。
```
objectA.someObject = null;
objectB.anotherObject = null;
```
将变量设置为null意味着切断变量与它此前引用的值之间的联系。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。

## 性能问题

垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。在这种情况下，确定垃圾收集的时间间隔是一个非常重要的问题。说到垃圾收集器多久运行一次，不禁让人联想到IE因此声名狼藉的性能问题。IE的垃圾收集器是根据内存分配量运行的，具体一点说就是256个变量、4096个对象（或数组）字面量和数组元素或者64KB的字符串。达到上述任何一个临界值，垃圾收集器就会运行。这种实现方式的问题在于，如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题促使IE7重写了其垃圾收集例程。
随着IE7的发布，其Javascript引擎的垃圾收集例程改变了工作方式：触发垃圾收集的变量分配、字面量和（或）数组元素的临界值被调整为动态修正。IE7中的各项临界值在初始时与IE6相等。如果垃圾收集例程回收的内存分配量低于15%，则变量，字面量和（或）数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值。这一看似简单的调整，极大地提升了IE在运行包含大量Javascript的页面时的性能。
```
事实上，在有的浏览器中可以触发垃圾收集过程，但不建议这么做。
```

## 管理内存

使用具备垃圾收集机制的语言编写程序，开发人员一般不必操心内存管理的问题。但是，Javascript在进行内存管理及垃圾收集时面临的问题还是有点与众不同。其中最主要的一个问题，就是分配给web浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行Javascript的网页耗尽全部系统内存而导致面临系统崩溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及在一个线程中能够同时执行的语句数量。
因此确保占用最少的内存可以让页面获得更好的性能。而优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为null来释放其引用--这个做法叫做解除引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动地解除引用。不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

- 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
- 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；
- 引用类型的值是对象，保存在堆内存中；
- 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
- 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；
- 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。
- 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；
- 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
- 函数的局部执行环境不仅有权访问函数作用域内的变量，而且有权访问其包含（父）环境，乃至全局环境；
- 全局执行环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部执行环境中的任何数据；
- 变量的执行环境有助于确定应该何时释放内存。
- 离开作用域的值将被自动标记为可回收，因此将在垃圾收集期间被删除；
- “标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存；
- 另一种垃圾收算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。Javascript引擎目前都不再使用这种算法；但在IE中访问非原生Javascript对象（如COM对象）时，这种算法仍然可能会导致问题；
- 当代码中存在循环引用现象时，“引用计数”算法就会导致问题；
- 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。

# 引用类型值

引用类型值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管ECMAScript从技术上讲是一门面向对象的语言，但它并不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。
```
虽然引用类型和类看起来相似，但它们并不是相同的概念。
类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。
类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为准则，而这些对象就被称为该类的实例。类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分多个属性。类与某个层的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。
类的出现，为面向对象编程的三个最重要的特性（封装性、继承性、多态性），提供了实现的手段。
```
如上所述，对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身是一个函数，只不过该函数是出于创建新对象的目的而定义的。ECMAScript提供了

## Object类型

到目前为止，我们看到的大多数引用类型值都是object类型的实例；而且，object也是ECMAScript中使用最多的一个类型。虽然object的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。
创建object实例的方式有两种。第一种是使用new操作符后跟object构造函数。另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。
虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数函数传递大量可传递参数的首选方式。
```
这种传递参数的模式最适合需要向函数传入大量可选参数的情形。一般来说，命名参数虽然容易处理，但在有多个可选参数的情况下就会显得不够灵活。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。
```

一般来说，访问对象属性时使用的都是点表示法，这也是很多面向对象语言中通用的语法。不过，在Javascript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。
通常，除非必须使用变量来访问属性，否则建议使用点表示法。

# Array类型

除了Object之外，Array类型恐怕是ECMAScript中的数组与其他多数语言中的数组有着相当大的区别。虽然ECMAScript数组与其他语言中的数组都是数据的有序列表，但与其他语言不同的是，ECMAScript数组的每一项可以保存任何类型的数据。也就是说，可以用数组的第一位置来保存字符串，用第二个位置来保存数值，用第三个位置来保存对象，以此类推，而且，ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。

创建数组的方式有两种。第一种是使用Array构造函数。创建数组的第二种基本方式是使用数组字面量表示法。数组字面量是由一对包含数组项的方括号表示，多个数组项之间以逗号隔开。
```
与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数。
```
在读取和设置数组时，要使用方括号并提供相应值的基于0的数字索引。方括号中的索引表示要访问的值。数组的项数保存在其length属性中，这个属性始终会返回0或更大的值。
```
数组最多可以包含4294967295个项，这几乎已经能够满足任何编程需要了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。
```

## 检测数组

- instanceof Array
instanceof操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如果你从一个框架向另外一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。
- Array.isArray() 

## 转换方法

如前所述，所有对象都具有toLocaleString()，toString()和valueOf()方法。其中，调用数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。而调用valueOf()返回的还是数组。实际上，为了创建这个字符串会调用数组每一项的toString()方法。
```
var colors = ["red", "green", "blue"];
console.log(colors.toString());    // red, green, blue
console.log(colors.valueOf());     // red, green, blue
console.log(colors);               // red, green, blue
```
另外，toLocaleString()方法经常也会返回与toString()和valueOf()方法相同的值，但也不总是如此。当调用数组的toLocaleString()方法时，它也会创建一个数组值的以逗号分隔的字符串。而与前两个方法唯一的不同之处在于，这一次为了取得每一项的值，调用的是每一项的toLocaleString()方法，而不是toString()方法。
```
var person1 = {
    toLocaleString: function () {
        return "Nikolaos";
    },
    toString: function () {
        return "Nicholaos";
    }
}
var person2 = {
    toLocaleString: function () {
        return "Grigorios";
    },
    toString: function () {
        return "Greg";
    }
}
var people = [person1, person2];
console.log(people);                   //Nicholaos, Greg
console.log(people.toString());        //Nicholaos, Greg
console.log(people.toLocaleString());  //Nikolaos, Grigorios
```
数组继承的toLocaleString()、toString()和valueOf()方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用join()方法，则可以使用不同的分隔符来构建这个字符串。join()方法只接受一个参数，即用作分隔符的字符串，然后返回包含所有数组的项的字符串。
```
var colors = ["red", "green", "blue"];

console.log(colors.join(","));  //red,green,blue
console.log(colors.join("||")); //red||green||blue
```
如果数组中的某一项的值是null或者是undefiend，那么该值在join()、toLocaleString()、toString()和valueOf()方法返回的结果中以空字符串表示。

## 栈方法

ECMAScript数组也提供了一种让数组的行为类似于其他数据结构的方法。具体说来，数组可以表现得就像栈一样，后者是一种可以限制插入和删除项的数据结构。栈是一种LIFO(Last-In-First-Out，后进先出)的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置--栈的顶部。ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。
push()方法可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。而pop()方法则从数组末尾移除最后一项，减少数组的length值，然后返回移除的值。

## 队列方法

栈数据结构的访问规则是LIFO（后进先出），而队列数据结构的访问规则是FIFO（First-In—First-Out，先进先出）。队列在列表的末端添加项，从列表的前段移除项。由于push()是向数组末端添加项的方法，因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是shift()，它能够移除数组中的第一个项并返回该项并返回该项，同时将数组长度减1。结合使用push()和shift()方法，可以像使用队列一样使用数组。
ECMAScript还为数组提供了一个unshift()方法。顾名思义，unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组长度。因此，同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项。
```
IE7及更早版本对JavaScript的实现中存在一个偏差，其unshift()方法总是返回undefined而不是数组的长度。IE8在非兼容模式下会返回正确的长度值。
```

## 重排序方法

数组中已经存在两个可以直接用来重排序的方法：reverse()和sort()。reserver()方法会反转数组项的顺序。
在默认情况下，sort()方法按升序排列数组项--即最小的值位于最前面，最大的值排在最后面。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串。sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值的前面。
比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数。比较函数可以适用于大多数数据类型，只要将其作为参数传递给sort()方法即可。在将比较函数传递到sort()方法之后，数值仍然保持了正确的升序。
当然，也可以通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可。比较函数在第一个值应该位于第二个之后的情况下返回正数，而在第一个值应该在第二个之前的情况下返回负数。交换返回值的意思是让更大的值排位更靠前，也就是对数组按照降序排序。当然，如果只想反转数组原来的顺序，使用reverse()方法更快一些。
```
reverse()和sort()方法的返回值是经过排序之后的数组。
```
对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以使用一个更简单的比较函数。由于比较函数通过返回一个小于零、等于零或大于零的值来影响排序结果，因此减法操作就可以适当地处理所有情况。

## 操作方法

concat()方法:
concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat()方法的是一个或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的值不是数组，这些值就会被简单地添加到结果数组的末尾。

slice()方法:
它能够基于当前数组中的一个或多个项创建一个新数组。slice()方法可以接受一个或两个参数，即要返回项的初始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项--但不包括结束位置的项。注意，slice()方法不会影响原始数组。
```
如果slice()方法的参数中有一个负数，则用数组的长度加上该数来确定相应的位置。
```

splice()方法:
splice()方法主要用途是向数组的中部插入项。
- 删除：可以删除任意数量的项，只需指定两个参数：要删的第一项的位置和要删除的项数。
- 插入：可以向指定位置插入任意数量的项，只需提供三个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以及任意多个项。
- 替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定三个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。

## 位置方法

ECMAScript5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。
这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说要求查找的项必须严格相等（就像使用===一样）。

## 迭代方法

ECMAScript5为数组定义了五个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选）运行该函数的作用域对象--影响this的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用方法的不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。
- every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回true；
对every()方法来说，传入的函数必须对每一项都返回true，这个方法才返回true；否则，它就返回false；
- filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组；
filter()方法利用指定的函数确定是否在返回的数组中包含某一项；
- forEach():对数组中的每一项运行给定函数，该方法无返回值；
forEach()方法只是对数组中的每一项运行传入的函数。这个方法没有返回值，本质上与使用for循环迭代数组一样。
- map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组；
map()方法返回的也是一个数组，而这个数组的每一项都是在原始数组中的对应项上运行传入函数的结果。
- some():对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。
some()方法，只要传入的函数对数组中的某一项返回true，就会返回true。


## 归并方法

ECMAScript5还新增了两个归并数组的方法: reduce()和reduceRight()。这个两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()方法则从数组的最后一项开始，向前遍历到第一项。
这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给reduce()和reduceRight()的函数接收四个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动转给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组第一项，第二个参数就是数组的第二项。
```
var values = [1, 2, 3, 4, 5];
var sum = values.reduce(function (prev, cur, index, array) {
    return prev + cur;
});
console.log(sum);     //   15
```
使用reduce()和reduceRight()，主要取决于要从哪头开始遍历数组。除此之外，他们完全相同。

# Date类型

Date类型使用UTC( Coordinated Universal Time，国际协调时间 )1970年1月1日午夜（零时）开始经过的毫秒数来保存日期。在使用这种数据存储格式的条件下，Date类型保存的日期能够精确到1970年1月1日之前或之后的285616年。
在调用Date构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象，必须传入表示该日期的毫秒数（即从UTC时间1970年1月1日午夜零时起至该日期止经过的毫秒数）。为了简化这一计算过程，ECMAScript提供了两个方法：Date.parse()和Date.UTC()。
其中，Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。将地区设置为美国的浏览器通常都接受下列日期格式：
- "月/日/年"，如6/13/2014;
- "英文月名 日，年"，如January 12, 2004;
- "英文星期几 英文月名 日 年 时:分:秒 时区"，如Tue May 25 2004 00:00:00 GMT-0700;
- ISO 8601 扩展格式 YYYY-MM-DDTHH:mm:ss:sssZ（例如2004-5-25T00:00:00:000Z）;
如果传入Date.parse()方法的字符串不能表示日期，那么它会返回Nan。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()方法

Date.UTC()方法同样也返回表示日期的毫秒数，但它与Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别为年份、基于0的月份（一月是0，二月是1，以此类推）、月中的哪一天（1到31）、小时数（0到23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为1；如果省略其他参数，则统统假设为0。
如同模仿Date.parse()方法一样，Date构造函数也会模仿Date.UTC()，但有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date构造函数接收的参数仍然与Date.UTC()相同。因此，如果第一个参数是数值，Date构造函数就会假设该值是日期中的年份，而第二个参数是月份，以此类推。
ECMAScript5添加了Date.now()方法，返回表示调用这个方法时的日期和时间的毫秒数，这个方法简化了使用Date对象分析代码的工作。

## 继承的方法

与其他引用类型一样，Date类型也重写了toLocaleString()、toString()和valueOf()方法，但是这些方法返回的值与其他类型中的方法不同。Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM和PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。

## 日期格式化方法

- toDateString()--以特定于实现的格式显示星期几、月、日和年；
- toTimeString()--以特定于实现的格式显示时、分、秒和时区；
- toLocaleDateString()--以特定于地区的格式显示星期几、月、日和年；
- toLocaleTimeString()--以特定于实现的格式显示时、分和秒；
- toUTCString()--以特定于实现的格式完整的UTC日期。
```
除了上述介绍的方法之外，还有一个名叫toGMTString()的方法，这是一个与toUTCString()等价的方法，其存在目的在于确保向后兼容。不过，ECMAScript推荐现在编写的代码一律使用toUTCString()方法。
```

## 日期/时间组件方法

- getTime()--返回表示日期的毫秒数；与valueOf()方法返回的值相同；
- setTime(毫秒)--以毫秒数设置日期，会改变整个日期；
- getFullYear()--获得四位数的年份；
- getUTCFullYear()--返回UTC日期的四位数年份；
- setFullYear(年)--设置日期的年份；传入的年份值必须是四位数字；
- setUTCFullYear(年)--设置UTC日期的年份；传入的年份值必须是四位数字；
- getMonth()--返回日期中的月份；其中0表示一月，11表示十二月；
- getUTCMonth()--返回UTC日期中的月份；其中0表示一月，11表示十二月；
- setMonth(月)--设置日期的月份；传入的月份值必须大于0，超过11则添加年份；
- setUTCMonth(月)--设置UTC日期的月份；传入的月份值必须大于0，超过11则添加年份；
- getDate()--返回日期月份中的天数（1～31）；
- getUTCDate()--返回UTC日期月份中的天数（1～31）；
- setDate(日)--设置日期月份中的天数；如果传入的值超过了该月中应有的天数，则增加月份；
- setUTCDate(日)--设置UTC日期月份中的天数；如果传入的值超过了该月中应有的天数，则增加月份；
- getDay()--返回日期中星期的星期几；其中0表示星期天，6表示星期六；
- getUTCDay()--返回UTC日期中星期的星期几；其中0表示星期天，6表示星期六；
- getHours()--返回日期中的小时数（0～23）；
- getUTCHours()--返回UTC日期中的小时数（0～23）；
- setHours(时)--设置日期中的小时数，传入的值超过了23则增加月份中的天数；
- setUTCHours(时)--设置UTC日期中的小时数，传入的值超过了23则增加月份中的天数；
- getMinutes()--返回日期中的分钟数（0～59）
- getUTCMinutes()--返回UTC日期中的分钟数（0～59）
- setMinutes(分)--设置日期中的分钟数；传入的值超过59则增加小时数；
- setUTCMinutes(分)--设置UTC日期中的分钟数；传入的值超过59则增加小时数；
- getSeconds()--返回日期中的秒数（0～59）
- getUTCSeconds()--返回UTC日期中的秒数（0～59）
- setSeconds(秒)--设置日期中的秒数；传入的值超过59则增加分钟数；
- setUTCSeconds(秒)--设置UTC日期中的秒数；传入的值超过59则增加分钟数；
- getMilliseconds()--返回日期中的毫秒数；
- getUTCMilliseconds()--返回UTC日期中的毫秒数；
- setMilliseconds(毫秒)--设置日期中的毫秒数；
- setUTCMilliseconds(毫秒)--设置UTC日期中的毫秒数；
- getTimezoneOffset()--返回本地时间与UTC时间相差的分钟数。例如，美国东部标准返回时间300。在某地进入夏令时的情况下，这个值会有所变化。

# RegExp类型

ECMAScript通过RegExp类型来支持正则表达式。
```
   var expression = /pattern/flag;
```
其中的模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一个或多个标志(flags),用以标明正则表达式的行为。
正则表达式的匹配模式支持下列3个标志：
- g:表示全局(global)模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止；
- i:表示不区分大小写(case-insensitive)模式，即在确定匹配项时忽略模式与字符串的大小写；
- m:表示多行(multiline)模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。

与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包含：
```
()[]{}\^$|?*+.
```
这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须要对它们进行转义。

定义正则表达式有两种方式：
- 以字面量形式来定义；
- 使用RegExp构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串。
要注意的是，传递给RegExp构造函数的两个参数都是字符串（不能把正则表达式字面量传递给RegExp构造函数）。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如\n(字符\在字符串中通常被转义为\\，而在正则表达式字符串中就会变成\\\\)。
使用正则表达式字面量和使用RegExp构造函数创建的正则表达式不一样。在ECMAScript3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。
例：
```
var re = null,
    i;

for ( i = 0; i < 10; i ++ ) {
    re = /cat/g;
    console.log(re.test("catastrophe"));
}
for ( i = 0; i < 10; i ++ ) {
    re = new RegExp("cat", "g");
    console.log(re.test("catastrophe"));
}
```
在第一个循环中，即使是循环体中指定的，但实际上只为/cat/创建了一个RegExp实例。由于实例属性(下一节介绍实例属性)不会重置，所以在循环中再次调用test()方法会失败。这是因为第一次调用test()找到了"cat"，但第二次调用是从索引为3的字符(上一次匹配的末尾)开始的，所以就找不到它了。由于会测试到字符串末尾，所以下一次再调用test()就又从开头开始了。
第二个循环使用RegExp构造函数在每次循环中创建正则表达式。因为每次迭代都会创建一个新的RegExp实例，所以每次调用test()都会返回 true。
ECMAScript5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例。

## 实例属性

RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。
- global:布尔值，表示是否设置了g标志；
- ignoreCase:布尔值，表示是否设置了i标志；
- lastIndex:整数，表示开始搜索下一个匹配项的字符位置，从0算起；
- multiline:布尔值，表示是否设置了m标志；
- source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。


## RegExp实例方法

RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置，而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。
```
var text = "mom and dad and baby";
var pattern = /mom( and dad ( and baby)?)?/gi;

var matches = pattern.exec(text);
console.log(matches.index);     // 0
console.log(matches.input);     // "mom and dad and baby"
console.log(matches[0]);        // "mom and dad and baby"
console.log(matches[1]);        // " and dad and baby"
console.log(matches[2]);        // " and baby"
```
最内部的捕获组匹配"and baby"，而包含它的捕获组匹配"and dad"或者"and dad and baby"。当把字符串传入exec()方法中之后，发现了一个匹配值。因为整个字符串本身与模式匹配，所以返回的数组matches的index属性值为0。数组中的第一项是匹配的整个字符串，第二项包含与第一项捕获组匹配的内容，第三项包含与第二个捕获组匹配的内容。
对于exec()方法而言，即使在模式中设置了全局标志(g)，它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项。
```
var text = "cat, bat, sat, fat";
var pattern1 = /.at/;

var matches = pattern1.exec(text);
console.log(matches.index);       // 0
console.log(matches[0]);          // cat
console.log(pattern1.lastIndex);  // 0

matches = pattern1.exec(text);
console.log(matches.index);       // 0
console.log(matches[0]);          // cat
console.log(pattern1.lastIndex);  // 0

var pattern2 = /.at/g;
matches = pattern2.exec(text);
console.log(matches.index);       // 0
console.log(matches[0]);          // cat
console.log(pattern2.lastIndex);  // 3

matches = pattern2.exec(text);
console.log(matches.index);       // 5
console.log(matches[0]);          // bat
console.log(patters.lastIndex);   // 8
```
这个例子中的第一个模式pattern1不是全局模式，因此每次调用exec()返回的都是第一个匹配项("cat")。而第二个模式pattern2是全局模式，因此每次调用exec()都会返回字符串中的下一个匹配项，直至搜索至字符串末尾为止。此外，还应该注意模式的lastIndex属性的变化情况。在全局匹配模式下，lastIndex的值在每次调用exec()后都会增加，而在非全局模式下则始终保持不变。
```
IE的JavaScript实现在lastIndex属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。
```
正则表达式的第二个方法是test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便。因此，test()方法经常被用在if语句中。
```
var text = "000-00-0000";
var pattern = /\d(3)-\d(2)-\d(4)/;

if ( pattern.test(text) ) {
    console.log("matched");
}
```
在这个例子中，使用正则表达式来测试一个数组序列。如果输入的文本与模式匹配，则显示一条消息。这种用法经常出现在验证用户输入的情况下，因为只想知道输入是不是有效，并不关心它为什么无效。
RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关。
```
var pattern = new RegExp("\\[bc\\]at", "gi");

console.log(pattern.toLocaleString());       // /\[bc\]at/gi
console.log(pattern.toString());             // /\[bc\]at/gi
```
**正则表达式的valueOf()方法返回的是正则表达式本身**

## RegExp构造函数属性

RegExp构造函数包含一些属性（这些属性在其他语言中被看成是静态属性）。这些属性适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。关于这些属性的另一个独特之处，就是可以通过两种方式访问它们。换句话说，这些属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。
```
长属性名 - 短属性名 - 说明
input - $_ - 最近一次要匹配的字符串。Opera未实现此属性。
lastMatch - $& - 最近一次的匹配项。Opera未实现此属性。
lastParen - $+ - 最近一次匹配的捕获组。Opera未实现此属性。
leftContext - $` - input字符串中lastMatch之前的文本。
multiline - $* - 布尔值，表示是否所有表达式都使用多行模式。IE和Opera未实现此属性。
rightContext - $' - input字符串中lastMatch之后的文本。
```
使用上述属性可以从exec()或test()执行的操作中提取出更具体的信息。
除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是RegExp.$1、RegExp.$2...RegExp.$9，分别用于存储第一，第二...第九个匹配的捕获组。在调用exec()和test()方法时，这些属性会被自动填充。

## 模式的局限性

ECMAscript正则表达式不支持下列特性：
- 匹配字符串开始和结尾的\A和\Z锚，但是支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾；
- 向后查找，但是完全支持向前查找；
- 交集和并集类；
- 原子组；
- Unicode支持(单个字符串除外，如/uFFFF);
- 命名的捕获组，但支持编号的捕获组；
- s(single, 单行)和x(free-spacing, 无间隔)匹配模式；
- 条件匹配；
- 正则表达式注释。

# Funciton类型

每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。函数通常是使用函数声明语法定义的：
```
    function functionName (param1, param2) {
        statements
    }
    var functionName = function (param1, param2) {
        statements
    };
```
使用函数表达式定义函数时，没有必要使用函数名；注意函数表达式末尾有一个分号，就像声明其他变量一样。
使用Function构造函数定义函数。Function构造函数可以接收任意数量的参数，但最后一个参数始终都会被看成是函数体，而前面的参数则枚举出了新函数的参数：
```
    var functionName = new Function("param1", "param2", "statements");
```
从技术的角度讲，这是一个函数表达式。但是，不推荐如此定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的。
由于函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有多个函数名。

## 没有重载（深入理解）

将函数名想象为指针，也有助于理解为什么ECMAScript中没有函数重载的概念：
```
function functionName (param1, param2)  {
    statements;
}
function functionName (param1, param2,  param3) {
    statements;
}
```
相当于：
```
var functionName = function (param1, param2) {
    statements;
}
functionName = function  (param1, param2,  param3) {
    statements;
}
```
在创建第二个函数时，实际上覆盖了引用第一个函数的变量functionName。

## 函数声明与函数表达式

解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正地被解释执行。
```
console.log(sum(1, 2));     // 3
function sum(num1, num2) {
    return num1 + nums2;
}
```
上述代码完全可以正常运行。因为在代码开始执行之前。解析器就已经通过一个名为函数声明提升(function declaration hoisting)的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。如果像下面例子所示的，把上面的函数声明改为等价的函数表达式，就会在执行期间导致错误。
```
console.log(sum(1, 2));     // sum is undefined
var sum = function (num1, num2) {
    return num1 + num2;
}
```
以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量sum中不会保存有对函数的引用；而且，由于第一行代码就会导致"unexpected identifier"（意外标识符）错误，实际上也不会执行到下一行。
除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的。
```
也可以同时使用函数声明和函数表达式，例如var sum = function sum () {}。不过，这种语法在safari中会导致错误。
```

## 作为值的函数

因为ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。
```
function callSomeFunction (someFunction, someArguments) {
    return someFunction(someArguments);
}
function add10 (num) {
    return num + 10;
}
var result1 = callSomeFunction(add10, 10); // 20

function greeting (name) {
    return `Hello, ${name}`;
}
var result2 = callSomeFunction(greating, "Nicholas"); // "Hello, Nicholas"
```
这里的callSomeFunction()函数是通用的，即无论第一个参数中传递进来是什么函数，它都会返回执行第一个参数后的结果。还记得吧，要访问函数的指针而不执行函数的话，必须去除函数名后面的那对圆括号。因此上面例子中传递给callSomeFunction()的是add10()和greeting()，而不是执行他们之后的结果。
当然，可以从一个函数中返回另一个函数，而且这也是极为有用的一项技术。例如，假设有一个对象数组，我们想要根据某个对象属性对数组进行排序。而传递给数组sort()方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数。
```
function createComparisonFunction (propertyName) {
    return function (object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];

        if ( value1 < value2 ) {
            return -1;
        } else if ( value1 > value2 ) {
            return 1;
        } else {
            return 0;
        }
    };
}
```
这个函数定义看起来有点复杂，但实际上无非就是在一个函数中嵌套了另一个函数，而且内部函数前面加了一个return操作符。在内部函数接收到propertyName参数后，它会使用方括号表示法来取得给定属性的值。取得了想要的属性值之后，定义比较函数就非常简单了。上述函数可以像下方例子中这样使用：
```
var data = [{name: "Zed", age: 20}, {name: "Andrew", age: 26}];
data.sort(createComparisonFunction("name"));
console.log(data[0].name);      // "Andrew"
data.sort(createComparisonFunction("age"));
console.log(data[0].name);      // "Zed"
```

## 函数内部属性

在函数内部，有两个特殊的对象：arguments和this。其中，arguments是一个类数组对象，包含着传入函数中的所有参数。虽然arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。
阶乘函数：
```
function factorial(num) {
    if ( num <= 1 ) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
}
```
定义阶乘函数一般都要用到递归算法；在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名factorial紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用arguments.callee：
```
function factorial(num) {
    if ( num <= 1 ) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
```
在这个重写后的factorial()函数的函数体内，没有再引用函数名factorial。这样，无论引用函数时使用的是什么名字，都可以保证正常完成递归调用：
```
var trueFactorial = factorial;
factorial = function () {
    return 0
};

console.log(trueFactorial(5));    // 120
console.log(factorial(5));        // 0
```
函数内部的另一个特殊对象是this，其行为与Java和C#中的this大致类似。换句话说，this引用的是函数据以执行的环境对象--或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）:
```
window.color = "red";
var o = {
    color: "blue"
};

function sayColor () {
    console.log(this.color);
}

sayColor();      // "red"
o.sayColor = sayColor();
o.sayColor();    // "blue"
```
函数的名字仅仅是一个包含指针的变量而已。因此，即使是在不同环境中执行，全局的sayColor()函数和o.sayColor()指向的仍然是同一个函数。
ECMAScript5也规范了另一个函数对象的属性：caller。除了Opera的早期版本不支持，其他浏览器都支持这个ECMAScript3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用callee函数，他的值为null:
```
function outer() {
    inner();
}

function inner() {
    console.log(inner.caller);
}

outer();
```
为了实现更松散的耦合，也可以通过arguments.callee.caller来访问相同的信息:
```
function outer() {
    inner();
}
function inner() {
    console.log(arguments.callee.caller);
}
outer();
```
当函数在严格模式下运行时，访问arguments.callee会导致错误。ECMAScript5还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller和函数caller属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥探其他代码了。严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。
## 函数属性和方法

ECMAScript中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length和prototype。其中，length属性表示函数希望接受的命名参数的个数：
```
function sayHi() {
    console.log("Hi!");
}
function sayName(name) {
    console.log(name);
}
function sum(num1, num2) {
    return num1 + num2;
}
console.log(sayHi.length);  // 0
console.log(sayName.length);// 1
console.log(sum.length);    // 2
```
在ECMAScript核心所定义的全部属性中，最耐人寻味的就要数prototype属性了。对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。在ECMAScript5中，prototype属性是不可枚举的，因此使用for-in无法发现。
每个函数都包含两个非继承而来的方法：apply()和call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是Array的实例，也可以是arguments对象：
```
function sum(num1, num2) {
    return num1 + num2;
}
function callSum1 (num1, num2) {
    return sum.apply(this, arguments);
}
function callSum2 (num1, num2) {
    return sum.apply(this, [num1, num2]);
}

console.log(callSum1(10, 10));   // 20
console.log(callSum2(10, 10));   // 20
```
在严格模式下，未指定环境对象而调用函数，则this值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this值将是undefiend。
call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来：
```
function sum(num1, num2) {
    return num1 + num2;
}
function callSum(num1. num2) {
    sum.call(this, num1, num2);
}
console.log(callSum(10, 10));  // 20
```
至于是使用apply()还是call()，完全取决于你采取哪种给函数传递参数的方式最方便。如果你打算直接传入arguments对象，或者包含函数中先接收到的也是一个数组，那么使用apply()肯定更方便；否则，选择call()可能更合适。（在不给函数传递参数的情况下，使用哪个方法都无所谓）。事实上，传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域：
```
window.color = "red";
var o = {
    color: "blue"
};
function sayColor() {
    console.log(this.color);
}
sayColor.apply(this);         // "red"
sayColor.apply(window);       // "red"
sayColor.apply(o);            // "blue"
```
使用call()或apply()来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。ECMAScript5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值：
```
window.color = "red";
var o = {
    color: "blue"
};
function sayColor() {
    console.log(this.color);
}
var objectSayColor = sayColor.bind(o);
objectSayColor();                    // "blue"
```
每个函数继承的toString()和toLocaleString()方法始终都返回函数的代码。返回代码的格式则因浏览器而异--有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的valueOf()方法同样也只返回函数代码。

## 基本包装类型

为了便于操作基本类型值，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String。这些类型与本章介绍的其他引用类型相似，但同时也具有各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据：
```
var s1 = "some text";
var s2 = s1.substring(0);
```
在读取模式中访问字符串时，后台都会自动完成下列处理：
(1)创建String类型的一个实例；
(2)在实例上调用指定的方法；
(3)销毁这个实例。
```
var s1 = new String("somw text");
var s2 = s1.substring(0);
s1 = null;
```
经过此番处理，基本的字符串就变得对象一样了。而且，上面这三个步骤也分别适用于Boolean和Number类型对应的布尔值和数字值。
引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着不能在运行时为基本类型值添加属性和方法。
当然，可以显式地调用Boolean、Number和String来创建基本包装类型的对象。不过，应该在绝对必要的情况下再这样做，因为这种做法很容易让人分不清自己是在处理基本类型还是引用类型的值。对基本包装类型的实例调用typeof会返回"object"，而且所有基本包装类型的对象都会被转化为布尔值true。
Object构造函数也像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。
把字符串传给Object构造函数，就会创建String的实例；而传入数值参数会得到Number的实例，传入布尔值参数就会得到Boolean的实例。
要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。
尽管不推荐使用显式的方法去创建基本包装类型的对象，但它们操作基本类型值的能力还是相当重要的。而每个基本包装类型都提供了操作相应值的便携方法。

### Boolean类型
Boolean类型是与布尔值对应的引用类型。要创建Boolean对象，可以直接调用Boolean构造函数并传入true或者false值：
```
var booleanObject = new Boolean(true);
```
Boolean类型的实例重写了valueOf()方法，返回基本类型值true或false；重写了toString()方法，返回字符串"true"和"false"。可是，Boolean对象在ECMAScript中的用处不大，因为它经常会造成人们的误解。最常见的问题就是在布尔表达式中使用Boolean对象：
```
var falseObject = new Boolean(false);
console.log(falseObject && true);    // true

var falseValue = false;
console.log(falseValue && true);     // false
```
基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回"boolean"，而对引用类型返回"object"。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false：
```
console.log(typeof falseObject);     // object
console.log(typeof falseValue);      // boolean
console.log(falseObject instanceof Boolean); // true
console.log(falseValue instanceof Boolean);  // false
```
理解基本类型的布尔值和Boolean对象之间的区别非常重要。**建议，永远不要使用Boolean对象。**

### Number类型
Number是与数字值对应的引用类型。要创建Number对象，可以在调用Number构造函数时向其中传递相应的数值：
```
var numberObject = new Number(10);
```
与Boolean一样，Number类型也重写了valueOf()、toLocaleString()和toString()方法。重写后的valueOf()方法返回对象表示的基本类型的数值，另外两个方法则返回字符串形式的数值。还可以为toString()方法传递一个表示基数的参数，告诉它返回几进制数值的字符串形式：
```
var num = 10;
console.log(num.toString());      // "10"
console.log(num.toString(2));     // "1010"
console.log(num.toString(8));     // "12"
console.log(num.toString(10));    // "10"
console.log(num.toString(16));    // "a"
```
除了继承的方法之外，Number类型还提供了一些用于将数值格式化为字符串的方法。其中toFixed()方法会按照指定的小数位返回数值的字符串表示，能够自动舍入的特性，使得toFixed()方法很适合处理货币值。但需要注意的是，不同浏览器给这个方法设定的舍入规则可能会有所不同。再给toFixed()传入0的情况下，IE8以及之前版本不能正确舍入范围在{(-0.94, -0.5],[0.5, 0.94)}之间的值。对于这个范围内的值，IE会返回0，而不是-1或1；其他浏览器都能返回正确的值。IE9修复了这个问题。
**toFixed()方法可以表示带有0到20个小数位的数值。但这只是标准实现的范围，有些浏览器也可能支持更多位数**
另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法（也称e表示法）表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数：
```
var num = 10
console.log(num.toExponential(1));   // 1.0e+1
```
对于一个数值来说，toPrecision()方法可能会返回固定大小(fixed)格式，也可能返回指数(exponential)格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。
```
toPrecision()方法可以表现1到21位小数。某些浏览器支持的范围更大，但这是典型实现的范围。
```
与Boolean对象类似，Number对象也以后台方式为数值提供了重要的功能。但与此同时，仍不推荐直接实例化Number类型，原因与显式创建Boolean对象一样。具体来讲，就是在使用typeof和instanceof操作符测试基本类型值与引用类型数值时，得到的结果完全不同。

### String类型

String类型是字符串的对象包装类型，使用String构造函数来创建：
```
var stringObject = new String("hello world");
```
String对象的方法也可以在所有基本的字符串中访问到。其中，继承的valueOf()、toString()和toLocaleString()方法，都返回对象所表示的基本字符串值。
String类型的每个实例都有一个length属性，表示字符串中包含有多少个字符。
String类型提供了很多方法，用于辅助完成对ECMAScript中字符串的解析和操作。

- 字符方法
两个用于访问字符串中特定字符的方法是：charAt()和chatCodeAt()。这两个方法都接收一个参数，即基于0的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位位置的那个字符（ECMAScript中没有字符类型）：
```
var stringValue = "hello world";
console.log(stringValue.charAt(1));          // "e"
console.log(stringValue.charCodeAt(1));      // "101"
console.log(stringValue[1]);                 // "e"
```
ECMAScript5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符。使用方括号表示法访问个别字符的语法得到了IE8、FireFox、Safari、Chrome和Opera所有版本的支持。如果是在IE7及更早版本中使用这种语法，会返回undefined值（尽管根本不是特殊的undefined值）。
- 字符串操作方法
concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串：
```
var stringValue = "hello ";
console.log(stringValue.concat("world")); // "hello world"
console.log(stringValue);                 // "hello "
```
concat()方法可以接收任意多个参数，也就是说可以通过它拼接任意多个字符串：
```
var stringValue = "hello ";
console.log(stringValue.concat("world", "!")); // "hello world!"
console.log(stringValue);                      // "hello "
```
虽然concat()是专门用来拼接字符串的方法，但实践中使用更多的还是加号(+)。而且，使用加号操作符在大多数情况下都比使用concat()方法要简便易行(特别是在拼接多个字符串的情况下)。
ECMAScript还提供了三个基本子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接收一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符串后面的位置。而substr()的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和substring()也不会修改字符串本身的值--它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响：
```
var stringValue = "hello world";
console.log(stringValue.slice(3));        // "lo world"
console.log(stringValue.substr(3));       // "lo world"
console.log(stringValue.substring(3));    // "lo world"
console.log(stringValue.slice(3, 7));     // "lo w"
console.log(stringValue.substr(3, 7));    // "lo w"
console.log(stringValue.substring(3, 7)); // "lo worl"
```
在传递给这些方法的参数是负数的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0，substring()方法会把所有负值参数都转换为0：
```
var stringValue = "hello world";
console.log(stringValue.slice(-3));        // "rld"
console.log(stringValue.substr(-3));       // "rld"
console.log(stringValue.substring(-3));    // "hello world"
console.log(stringValue.slice(3, -4));     // "lo w"
console.log(stringValue.substr(3, -4));    // ""
console.log(stringValue.substring(3, -4)); // "hel"
```
- 字符串位置方法
有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返回子字符串的位置（如果没有找到该字符串，则返回-1）。这两个方法的区别在于：indexOf()方法是从字符串的开头向后搜索子字符串，而lastIndexOf()方法是从子字符串的末尾向前搜索子字符串：
```
var stringValue = "hello world";
console.log(stringValue.indexOf("o"));     // 4
console.log(stringValue.lastValueOf("o")); // 7
```
这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索。换句话说，indexOf()会从该参数指定的位置向后搜索，忽略该位置之前的所有字符；而lastIndexOf()则会从指定的位置向前搜索，忽略该位置之后的所有字符。
在使用第二个参数的情况下，可以通过循环调用indexOf()和lastIndexOf()来找到所有匹配的子字符串。
- trim()方法
ECMAScript5为所有字符串定义了trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。
由于trim()方法返回的字符串的副本，所以原始字符串中的前置及后缀空格会保持不变。支持这个方法的浏览器有IE9+、Firefox3.5+、Safari5+、Opera10.5+和Chrome。此外，Firefox3.5+、Safari5+Chrome8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。
- 字符串大小写转换方法
ECMAScript中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。其中，toLowerCase()和toUpperCase()是两个经典的方法，借鉴自jave.lang.String中的同名方法。而toLocaleLowerCase()和toLocaleUpperCase()方法则是针对特定地区的实现。对有些地区来说，针对地区的方法与其通用方法得到的结果相同，但少数语言（如土耳其语）会为Unicode大小写转换应用特殊的规则，这时候就必须使用针对地区的方法来保证实现正确的转换：
```
var lowString = "hello world";
var upString = "HELLO WORLD";
console.log(lowString.toUpperCase());       // "HELLO WORLD"
console.log(lowString.toLocaleUpperCase()); // "HELLO WORLD"
console.log(upString.toLowerCase());        // "hello world"
console.log(upString.toLocaleLowerCase());  // "hello world"
```
一般来说，在不知道自己的代码将在哪种语言环境中运行的情况下，还是使用针对地区的方法更稳妥一些。
- 字符串的模式匹配方法
match()方法：在字符串上调用这个方法，本质上与调用RegExp()的exec()方法相同。match()方法只接收一个参数，要么是一个正则表达式，要么是一个RegExp对象：
```
var stringValue = "cat, bat, sat, fat";
var pattern = /.at/;
var matches = stringValue.match(pattern);
console.log(matches.index);     // 0
console.log(matches[0]);        // "cat"
console.log(pattern.lastIndex); // 0
```
search()：这个方法的唯一参数和match()方法的参数相同，由字符串或RegExp对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。而且，search()方法始终是从字符串开头向后查找模式：
```
var stringValue = "cat, bat, sat, fat";
var pattern = /at/;
console.log(stringValue.search(pattern)); // 1
```
为了简化替换字符串的操作，ECMAScript提供了replace()方法。这个方法接收两个参数；第一个参数可以是一个RegExp对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志：
```
var stringValue = "cat, bat, sat, fat";
console.log(stringValue.replace("at", "ond"));  // "cond, bat, sat, fat"
console.log(stringValue.replace(/at/g, "ond")); // "cond, bond, sond, fond"
```
如果第二个参数是字符串，那么还可以使用一些特殊的字符序列，将正则表达式操作得到的值插入到结果字符串中：
```
$$: $
$&: 匹配整个模式的子字符串。与RegExp.lastMatch的值相同。
$': 匹配的子字符串之前的子字符串。与RegExp.leftContext的值相同。
$`: 匹配的子字符串之后的子字符串。与RegExp.rightContext的值相同。
$n: 匹配第n个捕获组的子字符串，其中n等于0～9。$1是匹配第一个捕获组的子字符串，$2是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串。
$nn: 匹配第nn个捕获组的子字符串，其中nn等于01～99。$01是匹配第一个捕获组的子字符串，$02是匹配第二个捕获组的子字符串，以此类推。如果正则表达式中没有定义捕获组，则使用空字符串。
```
replace()方法的第二个参数也可以是个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递三个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项······，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为replace()方法的第二个参数可以实现更加精细的替换操作。
最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接收可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。
对split()方法中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别，但对于未发现匹配项以及带有捕获组的模式，匹配的行为就不大相同了：
**IE8及之前版本会忽略捕获组。规定了应该将捕获组拼接到结果数组中。IE9能正确地在结果中包含捕获组；**
**Firefox3.6及之前的版本在捕获组未找到匹配项时，会在结果数组中包含空字符串；规定没有匹配项的捕获组在结果数组中应该用undefined表示。**
在正则表达式中使用捕获组时还有其他微妙的差别。在使用这种正则表达式时，一定要在各种浏览器下多做测试。

- localeCompare()方法
与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：
**如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；**
**如果字符串等于字符串参数，则返回0；**
**如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值要视实现而定）。**
再强调一遍，因为localeCompare()方法返回的数值取决于实现。
localeCompare()方法比较与众不同的地方，就是实现所支持的地区（国家和语言）决定了这个方法的行为。
- fromCharCode()方法
String构造函数本身有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串。从本质上来看，这个方法与实例方法charCodeAt()执行的是相反的操作。
- HTML方法
差不多都已经被废除了。

## 单体内置对象

内置对象的定义：由ECMAScript实现提供的、不依赖于宿主环境的对象，对这些对象在ECMAScript程序执行之前就已经存在了。意思是，开发人员不必显式地实例化内置对象。

### Global对象
Global（全局）对象可以说是ECMAScript中最特别的一个对象，因为不管你从什么角度看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和方法，都是Global对象的属性。

**1.URI编码方法**
Global对象的encodeURI()和encodeURIComponent()方法可以对URI(Uniform Resource Identifiers, 通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。
其中，encodeURI()主要用于整个URI，而encodeURIComponent()主要用于对URI中的某一段进行编码。它们的主要区别在于，encodeURI()不会对自身属于URI的特殊字符进行编码；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。
使用encodeURI()编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了%20。而encodeURIComponent()方法则会使用对应的编码转换所有非字母数字字符。这也正是可以对整个URI使用encodeURI()，而只能对附加在现有URI后面的字符串使用encodeURIComponent()的原因所在。
**一般来说，使用encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础URI进行编码**
与encodeURI()和encodeURIComponent()方法对应的两个方法分别是decodeURI()和decodeURIComponent()。其中，decodeURI()只能对使用encodeURI()替换的字符进行解码。同样的，decodeURIComponent()能够解码使用encodeURIComponent()编码的所有字符，即它可以解码任何特殊字符的编码。
```
decodeURI(),encodeURI()和decodeURIComponent(), encodeURIComponent()替代废弃的escape()和unescape()方法。URI方法能够编码所有Unicode字符。
```
**2.eval()方法**
整个ECMAScript中最强大的一个方法：eval()。eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript(或Javascript)字符串。
当解析器发现代码中调用eval()方法时，解析器会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过eval()执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链，这意味着通过eval()执行的代码可以引用在包含环境中定义的变量。同样的，也可以在eval()调用中定义一个函数，然后再在该调用的外部代码中引用这个函数。
在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。
严格模式下，在外部访问不到eval()中创建的任何变量或函数，因此前面两个例子都会导致错误。同样，在严格模式下，为eval赋值也会导致错误。
```
能够解释代码字符串的能力非常强大，但也非常危险。因此在使用eval()时必须极为谨慎，特别是在用它执行用户输入数据的情况下。否则，可能会有恶意用户输入威胁你的站点或应用程序安全的代码（即所谓的代码注入）。
```
**3.Global对象的属性**
- undefined - 特殊值undefined
- NaN - 特殊值NaN
- Infinity - 特殊值Infinity
- Object - Object对象构造函数
- Array - Array数组构造函数
- Function - Function函数构造函数
- Boolean - Boolean布尔构造函数
- String - String字符串构造函数
- Number - Number数字构造函数
- Date - Date日期构造函数
- RegExp - RegExp正则表达构造函数
- Error - Error错误构造函数
- EvalError - EvalErroreval()函数的错误
- RangeError - RangeError不在其所允许的范围或者是集合内
- ReferenceError - ReferenceError引用错误，引用一个不存在的变量
- SyntaxError - SyntaxError语法不合法
- TypeError - TypeError值的类型非预期类型
- URIError - URIError错误使用全局URI处理函数
ECMAScript5明确禁止给undefined，NaN和Infinity进行赋值，这样做即使在非严格模式下也会导致错误。
**4.window对象**
ECMAScript虽然没有指出如何直接访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。
```
JavaScript中的window对象除了扮演ECMAScript规定的Global对象的角色外，还承担了很多别的任务。
```
### Math对象
ECMAScript还为保存数学公式和信息提供了一个公共位置，即Math对象。相对于直接编写计算功能，Math对象提供的计算功能执行起来要快得多。Math对象中还提供了辅助完成这些计算机的属性和方法。
**1.Math对象的属性**
Math对象包含的属性大都是数学计算中可能会用到的一些特殊值:
- Math.E - 自然对数的底数，即常量e的值；
- Math.LN10 - 10的自然对数
- Math.LN2 - 2的自然对数
- Math.LOG2E - 以2为底e的对数
- Math.LOG10E - 以10为底e的对数
- Math.PI - π的值
- Math.SQRT1_2 - 1/2的平方根
- Math.SQRT2 - 2的平方根
**2.min()和max()方法**
Math对象还包含许多方法，用于辅助完成简单和复杂的数学计算。
其中，min()和max()方法用于确定一组数据中的最小值和最大值。这两个方法都可以接收任意多个数值参数，这两个方法经常用于避免多余的循环和在if语句中确认一组数的极限值。要找到数组中的最大值或最小值，可以使用apply方法：
```
var values = [1, 2, 3, 4, 5, 6, 7, 8];
var max = Math.max.apply(Math, values);
```
这个技巧的关键是把Math对象作为apply()的第一个参数，从而正确地设置this值。然后可以将任何数组作为第二个参数。
**3.舍入方法**
- Math.ceil()执行向上舍入，即总是将数值向上舍入为最接近的整数；
- Math.floor()执行向下舍入，即总是将数值向下舍入为最接近的整数；
- Math.round()执行标准舍入，即总是将数值四舍五入为最接近的整数。
**4.random()方法**
Math.random()方法返回大于等于零小于等于一的一个随机数。对于某些站点来说，这个方法非常实用，因为可以利用它来随机显示一些名人名言和新闻事件。
**5.其他方法**
- Math.abs(num)返回num的绝对值
- Math.exp(num)返回Math.E的num次幂
- Math.log(num)返回num的自然对数
- Math.pow(num, power)返回num的power次幂
- Math.sqrt(num)返回num的平方根
- Math.acos(x)返回x的反余弦值
- Math.asin(x)返回x的反正弦值
- Math.atan(x)返回x的反正切值
- Math.atan2(y, x)返回y/x的反正切值
- Math.cos(x)返回x的余弦值
- Math.sin(x)返回x的正弦值
- Math.tan(x)返回x的正切值

# 面向对象的程序设计
面向对象(Object-Oriented，OO)的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象。ECMAScript中没有类的概念，因此它的对象也与基于类的语言中的对象有所不同。
对象定义：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每一个属性或方法都有一个名字，而每个名字都映射到一个值。正因为如此，对象可以想象成散列表：无非就是一组名值对-键值对，其中的值可以是数据或函数。
每个对象都是基于一个引用类型创建的，这个引用类型可以是原声类型，也可以是开发人员定义的类型。

## 理解对象
创建自定义对象的最简单方式就是创建一个Object的实例，然后再为它添加属性和方法。
早期的JavaScript开发人员经常使用这个模式创建新对象。几年后，对象字面量成为创建这个对象的首选模式。
## 属性类型
ECMA-262第五版在定义只有内部才用的特性(attribute)时，描述了属性(property)的各种特征。ECMA-262定义这些特性是为了实现JavaScript引擎用的，因此在JavaScript中不能直接访问它们。为了表示特性是内部值，该规范把它们放在了两对方括号中。
ECMAScript中有两种属性：数据属性和访问器属性。
**1.数据属性**
数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有四个描述其行为的特性：
- [[Configurable]]: 表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性；
- [[Enumerable]]: 表示能否通过for-in循环返回属性；
- [[Writable]]: 表示能否修改属性的值；
- [[Value]]: 包含这个属性的数据值。读取属性值时，从这个位置读；写入属性值时，把新值保存在这个位置。这个特性的默认值为undefined。
要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符(descriptor)对象的属性必须是：configurable、enumerable、writable和value。设置其中的一或多个值，可以修改对应的特性值。
将对象的writable设置为false，当一个对象的属性的值不可修改时，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。类似的规则也适用于不可配置的属性。将对象的configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且一旦把属性定义为不可配置的，就不能再把对象变回可配置了。此时，在调用Object.defineProperty()方法修改除writable之外的特性，都会导致错误。也就是说，可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。
在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。多数情况下，可能都没有必要利用Object.defineProperty()方法提供的这些高级功能。
```
IE8是第一个实现Object.defineProperty()方法的浏览器版本。然而，这个版本的实现存在诸多限制；只能在DOM对象上使用这个方法，而且只能创建访问器属性。由于实现不彻底，不要在IE8中使用Object.defineProperty()方法。
```
**2.访问器属性**
访问器属性不包含数据值；它们包含一对儿getter和setter函数(不过，这两个函数都不是必需的)。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据：
- [[Configurable]]：表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性；
- [[Enumerable]]：表示能否通过for-in循环返回属性；
- [[Get]]：在读取属性时调用的函数。默认值为undefined；
- [[Set]]：在写入属性时调用的函数。默认值为undefined；
访问器属性不能直接定义，必须使用Object.defineProperty()来定义：
```
var book = {
    _year: 2004,
    edition: 1
};
Object.defineProperty(book, "year", {
    get: function () {
        return this._year;
    },
    set: function (newValue) {
        this.edition += newValue - this._year;
        this._year = newValue;
    }
});

book.year = 2005;
console.log(book.edition);   // 2
```
这是使用访问器属性的常见方法，即设置一个属性的值会导致其他属性发生变化。
不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。
在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：__defineGetter__()和__defineSetter__()。
## 定义多个属性
由于为对象定义多个属性的可能性很大，ECMAScript5又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。
## 读取属性的特性
使用ECMAScript5的Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value。在JavaScript中，可以针对任何对象--包括DOM和BOM对象，使用Object.getOwnPropertyDescriptor()方法。

# 创建对象
虽然Object构造函数或对象字面量都可以用来创建单个对象，但这些方法有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。
## 工厂模式
工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程。考虑到在ECMAScript中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节：
```
function createPerson (name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        console.log(this.name);
    };

    return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```
可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题(即怎样知道一个对象的类型)。随着JavaScript的发展，又一个新模式出现了。
## 构造函数模式
ECMAScript中的构造函数可用来创建特定类型的对象。像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。
```
function Person (name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function () {
        console.log(this.name);
    };
}

var person1 = new Person("Nicholas", 29, "Software Engineer");
var person2 = new Person("Greg", 27, "Doctor");
```
构造函数模式与工厂模式显著的区别是：
- 没有显式地创建对象；
- 直接将属性和方法赋给了this对象；
- 没有return语句。
此外，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以小写字母开头。这个做法借鉴自其他面向对象语言，主要是为了区别于ECMAScript中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。
要创建构造函数的新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下四个步骤：
- 创建一个新对象；
- 将构造函数的作用域赋给新对象(因此this就指向了这个新对象)；
- 执行构造函数中的代码(为这个新对象添加属性)；
- 返回新对象。
构造函数模式创建出来的对象都有一个constructor(构造函数)属性，该属性指向创建该对象的构造函数。对象的constructor属性最初是用来标识对象类型的。但是提到检测对象类型，还是instanceof操作符要更可靠一些。通过构造函数创建出来的所有对象既是Object的实例，同时也是构造函数的实例，这一点可以通过instanceof操作符可以得到验证。创建自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型；而这正是构造函数模式胜过工厂模式的地方。
**1.将构造函数当作函数**
构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过new操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过new操作符来调用，那它和普通函数也不会有什么两样。
**2.构造函数的问题**
构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。说明白些，以这种方式创建函数，会导致不同的作用域链和标识符解析，但创建Function新实例的机制仍然是相同的。因此，不同实例上的同名函数是不相等的。然而，创建两个完全同样任务的Function实例的确没有必要；况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。那么将构造函数中的方法定义转移到构造函数外，然后在构造函数中去引用这个函数。这样做的确解决了两个函数做同一件事的问题，可是新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。更让人无法接受的是：如果对象需要定义很多方法，那么就要定义很多个全局函数，于是自定义的引用类型就丝毫没有封装性可言了。
## 原型模式








